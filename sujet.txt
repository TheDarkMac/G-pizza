. - Implémentation d’API REST.TD2 - Application de gestion de restaurant Contexte fictif : La chaîne de restauration “La Gastronomie Pizza” est une référence nationale du fast-food à Madagascar depuis plus d’une vingtaine d’années. Elle possède des points de vente partout à Madagascar, dont plusieurs points de ventes implantés dans les grandes villes. Notre application a deux objectifs principaux : Au sein de chaque point de vente, faciliter la gestion des stocks, la gestion des commandes et des ventes, ainsi que le flux de trésorerie à travers les ventes et achats effectués.- Au sein du siège, qui effectue un suivi centralisé des opérations de chaque point de vente, avoir un dashboard qui synthétise les données issues de tous les points de vente en temps réel.Dans le cadre de notre projet, nous allons faire évoluer petit à petit l’application en développant petit à petit les fonctionnalités attendues.Partie 1 : Gestion des plats Le cœur de l’activité de l’entreprise est de proposer des plats et des menus à leurs clients. Nous allons commencer ainsi par le cœur même du métier.a. Un Plat ou Dish (en anglais) possède un nom, un prix de vente unitaire fixe, et il est composé de plusieurs Ingrédients ou Ingredient (en anglais).b. Un Ingredient possède un nom, la date et heure de dernière modification, un prix unitaire fixe et une unité qui peut être soit en grammes (g), en litres (L) ou en unité (U). Par exemple, on peut avoir les ingrédients suivants :ID Nom Date et heure de dernière modification Prix unitaire Unité 1 Saucisse 2025-01-01 00:00 20 G.2 Huile 2025-01-01 00:00 10 000 L.3 Oeuf 2025-01-01 00:00 1 000 U.4 Pain 2025-01-01 00:00 1 000 U c. Il est à noter qu’un Dish doit être composé d’au moins un Ingredient, et un Ingredient peut être retrouvé dans plusieurs plats ou dish différents. Pour chaque Dish, il faut spécifier la quantité unitaire nécessaire à chaque Ingredient qui le compose, quantité unitaire veut dire qu’il faut à la fois spécifier la quantité nécessaire (exprimé en nombre décimale) ainsi que l’unité évoqué plus tôt, soit en gramme, soit en litre, soit en unité. Voici une illustration d’un plat : Et voici les ingrédients qui composent le plat “Hot Dog” : Notez que ces ingrédients ou leurs quantités peuvent changer et donc sont variables. Par changer les ingrédients, nous voulons dire qu’on peut à la fois ajouter d’autres ingrédients comme en supprimer. 1. Créez un nouveau projet sur Java, de type console. Installer les dépendances nécessaires pour pouvoir connecter l’application avec une base de données Postgres, ainsi que d’effectuer des tests unitaires avec JUnit. 2. Créer les scripts de création du schéma de la base de données correspondantes et insérer dans le projet, dans un package db.migration, et ajouter des données de test selon les illustrations données plus tôt (Hot Dog et ses ingrédients avec la même quantité de composition et les mêmes prix) dans un autre package db.testdata. En particulier, les unités doivent être exprimés en ENUM directement dans la base de données. ID Nom Prix de vente unitaire 1 Hot dog 15 000.Ingrédients Quantité nécessaire Unité.Saucisse 100 G.Huile 0,15 L.Oeuf 1 U.Pain 1 U 3. Créer les classes nécessaires pour pouvoir convertir les données issues de la table en objet sur Java, notamment la DataSource, les DAO, etc. En particulier : a. Les unités doivent être exprimées en type ENUM et non en tant que String sur Java. b. La classe Dish (désignant un Plat), doit directement avoir un attribut de type liste d’ingrédients qui le compose ainsi que les quantités unitaires nécessaires. 4. À travers les données de tests énoncés précédemment, ainsi que la structure des classes évoquées plus tôt, vérifiez à travers un test d’intégration (non mockées) que l’ensemble des coûts des ingrédients du plat Hot Dog = 5500.PS : n’oubliez pas de configurer les variables d’environnement avant de lancer les tests avec les valeurs réelles. 5. Créez une fonction qui permet de filtrer, trier et paginer la liste des ingrédients et ajouter les tests nécessaires pour vérifier que ça marche. En particulier, on peut filtrer et trier en même temps par nom, par unité, par un intervalle de prix, une intervalle de date de dernière modification ou tous ces attributs en même temps, et à la toute fin, les données retournées doivent être paginées correctement. 6. Consigne supplémentaire ajoutée en séance TD : historiser les prix de chaque ingrédient. Par défaut, un ingrédient doit avoir au moins un prix d’ingrédient et peut avoir plusieurs pour chaque date différente. Un prix d’ingrédient n’est associé par contre qu’à un et un seul ingrédient. Par défaut, le prix d’un ingrédient correspond au dernier prix qui lui est associé, et nous avons la possibilité d’obtenir le prix composant un plat à une date donnée. a. Pour cela, vous pouvez soit modifier la méthode getIngredientsCost() de la classe Dish et y ajouter un argument LocalDate qui va spécifier la date de l'ingrédient qu’il faut, ou bien ajouter un argument List<DishIngredient> et donc le calcul va se faire à travers la liste fournie et non la liste associée par défaut à l’objet qui va être instancié de la classe Dish. b. Pour vérifier que ça marche, en faisant en sorte que la date par défaut soit égale à la date du jour, dans vos tests, faites en sorte que les prix les plus récents associés aux ingrédients composant le HotDog permettent d’obtenir le coût de 5500. Ensuite pour vérifier que la méthode qui permet de calculer les coûts des ingrédients à une date donnée fonctionne, ajouter à chaque ingrédient des prix à une daté antérieure (avant la date du jour) et vérifier pour cette date donnée si le coût des ingrédients sont bien mis à jour. 7. Ajouter une méthode à la classe Dish qui permet de calculer les marges brutes associées à un plat : Double getGrossMargin(); Cette méthode est obtenue à travers la différence entre le prix de vente unitaire fixe et le coût des ingrédients. Étant donné que les coûts des ingrédients peuvent être variables en fonction de la date, il faut que par défaut, nous obtenions les coûts de revient le plus proche ou égale à la date du jour. Et qu’il y ait une autre possibilité d’obtenir les marges brutes à travers une date donnée, similairement aux coûts des ingrédients. Ajouter les tests qui permettent d’assurer que les résultats obtenus sont corrects. Au stade actuel de notre application, nous avons la possibilité de gérer la composition des plats à travers les ingrédients, et d'identifier les coûts et les marges bénéficiaires. Nous allons maintenant commencer à gérer les stocks de ces ingrédients. Partie 2 : Gestion des stocks des ingrédients Gérer les stocks des ingrédients signifie suivre les mouvements d’entrée et de sortie de chaque ingrédient. En effet, lorsqu’un plat est vendu à une date donnée, ça veut dire que les ingrédients ont été utilisés. Pour approvisionner les nouveaux stocks, il est essentiel de faire des achats de nouveaux ingrédients. Un mouvement de stock peut être donc défini comme suit : - Type du mouvement : entrée ou sortie - Quantité de l’ingrédient : exprimé en nombre décimale - Unité : G, U ou L - Date et heure du mouvement du stock Un mouvement correspond à un Ingrédient spécifique, et un Ingrédient peut avoir plusieurs mouvements. Par défaut, nous allons supposer que le stock initial est égal à 0 pour chaque ingrédient. Travail à faire d’ici le 26/02/2025 : 1. Ajouter les tables nécessaires dans la base de données et ajouter les scripts dans le package db.migration pour gérer la gestion des stocks. Insérer des données de test qui correspond à ce que le 1er février 2025 à 8h, le stock a été approvsionné comme tel :a. Oeuf, 100 unités b. Pain, 50 unités c. Saucisse, 10 kg donc 10 000 g d. Huile, 20 L 2. Ajouter les classes nécessaires pour accéder et manipuler aux nouvelles tables qui permettent de gérer les données issues de la base de données, concernant la fonctionnalité de gestion de stock. En particulier, dans cette question, attardez vous sur la façon de récupérer uniquement les mouvements de stock. 3. Dans la classe Ingrédient, ajouter la ou les méthode(s) nécessaire(s) pour obtenir l’état des stocks (quantité et unité disponible) de l'ingrédient à une date donnée. Par défaut, la date de l’état du stock est la date du jour. a. Ajouter les tests nécessaires qui vont vérifier que pour nos ingrédients actuels, l’état des stocks correspond bien aux données énoncées précédemment, tant qu’il n’y a aucun mouvement de stock de type sortie associé aux ingrédients (œufs, pain, saucisse, huile). b. Maintenant, ajouter dans vos données de test dans la base de données, les mouvements de stocks de type sortie actuels, selon les dates respectives : i. Oeufs, 10 unités le 02 février 2025 à 10h ii. Oeufs, 10 unités le 03 février 2025 à 15h iii. Pain, 20 unités le 05 février 2025 à 16h Modifier maintenants les données ‘expected’ dans vos tests précédemment (qui tests la méthode Dish::getAvalaibleQuantity) pour correspondre à ces nouvelles données et faites en sorte que les quantités respectives de chaque ingrédient à la date par défaut (date d’aujourd’hui) soient : - Oeuf, 80 unités le 24 février 2025 à l'heure actuelle - Pain, 80 unités le 24 février 2025 à l’heure actuelle - Saucisse, 10 000 g le 24 février 2025 à l’heure actuelle - Huile, 20L le 24 février 2025 à l’heure actuelle 4. Étant donné que durant la question 2, vous ne vous êtes attardées que sur la récupération des mouvements au sein de la base de données, maintenant implémenter la création des mouvements de stock. En particulier, les mouvements ne doivent pas être modifiables, et donc dit immuables. Du moment, où un mouvement qu’il soit une entrée ou sortie est enregistré, on ne peut plus modifier la quantité ou la date, pour éviter les vols. a. Pour que les données des tests antérieurs ne soient pas impactés, créer deux nouveaux ingrédients, le sel avec comme unité le G, ainsi que le riz avec comme unité le G. Comme prix unitaire, respectivement, le sel coûte 2,5 Ar par G, et le riz 3,5 Ar par G à la date d’aujourd’hui. b. Ajouter des mouvements d’entrées et de sortie directement sur ces nouveaux ingrédients à travers des tests et vérifier que les données sont toujours bien à jour.À ce stade, il est possible de gérer le stock disponible des différents plats par date et leurs ingrédients respectifs. Il faut maintenant pouvoir gérer les commandes, de la préparation à la livraison, afin de faciliter le suivi des ventes plus tard. Partie 3 : Gestion des commandes Une commande est effectuée lorsqu’un client arrive au point de vente ou appelle le point de vente dans le cas d’une livraison et comporte une référence unique. Elle doit également se souvenir de la date et heure où on a créé la commande. Un plat peut être commandé plusieurs fois selon les quantités disponibles, et une commande peut comporter plusieurs plats en même temps, où chaque quantité dans le plat doit être spécifiée dans la commande. Il faut vérifier que la quantité disponible en stock doit être vérifiée avant de pouvoir passer une commande, sinon l’application doit retourner une erreur (exception). Le message d’erreur doit comporter les ingrédients qui manquent, la quantité manquante, ainsi que les plats concernés. Aussi, chaque plat dans une commande doit avoir un statut, et pareil pour la commande. Les statuts doivent passer les statuts suivants : - “CRÉÉ” lorsque la commande est créée, on n’effectue encore aucune vérification à ce stade étant donné qu’on peut encore modifier les plats et leurs quantités. - “CONFIRMÉ” lorsque la commande est validée, pareil pour chaque plat dans la commande. C’est au passage de “CRÉÉ” à “CONFIRMÉ” qu’on vérifie si les ingrédients disponibles sont suffisants. - “EN PRÉPARATION” pour la commande lorsque tous les plats ne sont pas en statut “TERMINÉ”. En effet, un plat dans une commande peut être déjà en statut “TERMINÉ”, mais les autres plats sont toujours en statut “EN PRÉPARATION”, et c’est dans ce cas là où la commande reste en statut “EN PRÉPARATION”. - “TERMINÉ”, lorsque tous les plats d’une commande sont en statut “TERMINÉ”. - “SERVI” lorsque le plat est livré. À chaque passage de statut d’un état à un autre d’un plat ou d’une commande, il faut savoir la date et heure de ce passage de statut. Et les seuls passages possible sont : CRÉÉ > CONFIRMÉ > EN_PREPARATION > TERMINÉ > SERVI. Autrement dit, on ne peut pas par exemple passer d’un statut TERMINÉ en statut EN_PREPARATION, et encore moins en statut CONFIRMÉ. Illustration : Un client arrive et commande deux hot dogs et une omelette. On va donc d’abord créer une commande et avoir un statut “CRÉÉ”. Lorsqu’on veut valider la commande, l’application doit vérifier si les quantités des ingrédients disponibles permettent de valider cette commande, sinon une erreur (exception) doit être retournée, notamment si les ingrédients disponibles ne permettent juste que de fabriquer un hot dog par exemple, donc le message d’erreur doit indiquer quels ingrédients sont manquants, par exemple “1 pain est nécessaire pour fabriquer 1 hot dog”. Si tous les ingrédients sont disponibles, alors la commande doit passer directement en “CONFIRMÉ”, qui est le statut initial d’une commande. Tous les plats présents dans la commande doivent également avoir le statut en “CONFIRMÉ”. Il faut passer manuellement la commande en statut “EN_PREPARATION”, et chaque plat présenté dans la commande va également être automatiquement mis à jour au statut “EN PRÉPARATION”, et les dates et heures de cette modification de statuts doivent être sauvegardées en même temps. Il est ensuite possible de passer un plat issu d’une commande en statut “TERMINÉ” un par un. La transformation du statut de la commande de “EN PREPARATION” en “TERMINÉ” se fait automatiquement lorsqu’on passe le dernier plat “EN PREPARATION” en “TERMINÉ”, mais on ne passe pas manuellement le statut de la commande en “TERMINÉ”. Pareil, lorsqu’on veut passer le statut d’une commande “TERMINÉ” en “SERVI”, c’est lorsqu’on passe tous les plats manuellement en statut “SERVI” que la commande va être passer en “SERVI”. Pour remettre dans le contexte réel, c’est le serveur qui va créer la commande et confirmer la commande. Une notification va être donnée au cuisinier qui va passer la commande en préparation. À chaque plat qui est terminé, le cuisinier va passer le statut en TERMINÉ jusqu’à ce que la commande passe en “TERMINÉ”. Ce passage de statut va notifier le serveur qu’il peut servir les plats et va effectuer un retour de va et vient petit à petit. Chaque fois qu’il va finir de servir un plat, il doit mettre à jour le statut de chaque plat compris dans une commande, jusqu’à ce que la commande passe en statut “SERVI”. Travail à faire : 1. Ajouter les tables et types enum nécessaires pour pouvoir gérer les commandes et les statuts qui y sont liés. N’oubliez pas qu’à la fois que la table liée à la commande et la table liée aux plats rattachés à une commande doivent être associées à une autre table (ou plusieurs tables) statuts. Tous les scripts doivent être ajoutés dans le package db.migration, et les données de test dans db.testdata. 2. Créer la classe “DishOrder” pour désigner un plat compris dans une commande, qui comporte un Dish, la quantité correspondant à la commande, la liste des statuts par lesquels un Dish est passé à une date et heure donnée. Ajouter les classes DAO nécessaires pour pouvoir obtenir et créer un DishOrder. En particulier la classe “DishOrder”, doit avoir une méthode getActualStatus, qui retourne le statut actuel du plat par rapport à la commande. 3. Créer la classe “Order” désignant une commande, ajouter ses attributs selon l’énoncé et veiller à typer correctement ses attributs en ajoutant la liste de DishOrder. Ajouter les classes DAO nécessaires pour pouvoir obtenir et obtenir une commande. a. Lorsqu’on crée une commande, il est possible qu’on ne fournit pas directement les plats qui y sont présents. Mais on peut les ajouter ou les modifier jusqu’à ce qu’on passe le statut en CONFIRMÉ. La modification dont on parle ici n’est pas les propriétés des plats en question, juste le choix du plat ou les quantités des plats. b. Lorsqu’on veut savoir l’état d’une commande, on peut l’identifier à travers sa référence unique. 4. La classe “Order” qui désigne une Commande, doit avoir les méthodes suivantes : a. Order::getActualStatus, qui permet de savoir le statut actuel d’une commande. b. Order::getDishOrders, qui permet d’identifier facilement les plats dans la commande, ainsi que leurs statuts. c. Order::getTotalAmount, qui permet d’obtenir le montant total correspondant à une commande, notamment par rapport aux prix de vente des plats et leurs quantités. TD2 - Application de gestion de restaurant | Partie 1 : Guide pour mieux comprendre Pour ceux qui rencontrent des difficultés sur les notions à maîtriser, nous allons décomposer les travaux à faire selon les matières que vous avez eu en L1 (PROG et DONNÉES), et suivez les étapes dans cet ordre. Pour la partie SQL : 1. Créer d’abord un nouvel utilisateur avec les informations de connexion (identifiant et mot de passe). Pour faire cela, il faut employer les syntaxes CREATE USER nom_user WITH PASSWORD ‘votre mot de passe’, qui pour rappel est équivalent à CREATE ROLE nom_user WITH LOGIN PASSWORD ‘votre mot de passe’. 2. Créer la base de données et attribuer les rôles nécessaires au nouvel utilisateur pour pouvoir effectuer les manipulations des schémas et des données pour la base de données nouvellement créée. La meilleure façon est de n’attribuer (GRANT) que les autorisations relatives à l’usage attendu qui est le CRUD, mais vous pouvez directement attribuer tous les privilèges pour éviter que ça ne vous ralentisse. Nous pouvons discuter plus de détails lors des séances en présentiel TD. 3. Créer les tables et les types correspondantes aux données décrites précédemment dont voici la représentation dans le modèle relationnel (colonnes soulignées sont des clés primaires, ceux qui sont préfixés d’un hashtag (#) sont des clés étrangères, et si ils sont à la fois soulignés et préfixés d’un hashtag donc à la fois clés primaires et étrangères) a. Dish (id_dish, name, unit_price) b. Ingredient (id_ingredient, name, unit_price, unit, update_datetime) c. Dish_Ingredient (#id_dish, #id_ingredient, required_quantity, unit) d. Unit de type ENUM : G, L, U L’intérêt d’avoir une table de jointure Dish_Ingredient ici est de faire en sorte qu’on n’ait pas à ajouter une nouvelle entrée Ingredient pour chaque plat, sachant que les propriétés telles que les prix sont les même pour n’importe quel ingrédient, qu’ils composent le plat “Hot Dog” ou le plat “Omelette”, pour le cas de l’oeuf par exemple. 4. Pour obtenir les ingrédients d’un plat ainsi que les quantités nécessaires, il suffit d’utiliser la table de jointure Dish_Ingredient, qui permet de gérer les relations many-to-many, et dans notre cas présent, associer un ingrédient à un plat. Il est tout à fait possible d’effectuer le calcul qui confirme la sommes des coûts des ingrédients du Hot Dog = 5500, en utilisant proprement la fonction SUM() et GROUP BY (). Les données concernées sont : unit_price * required_quantity pour obtenir le coût lié à chaque Ingrédient composant le plat et id_dish pour regrouper le calcul par le plat concerné. 5. Pour les filtres, tris et paginations : a. Exécutez un script SQL qui permet d’obtenir la liste des ingrédients qui contiennent “u” dans leur nom, dont le prix unitaire est inférieur ou égale à 1000. Normalement vous devez obtenir uniquement les ingrédients “Saucisse” et “Oeuf” comme résultat. Pour cela, vous devez employer correctement la syntaxe “WHERE” qui permet d’ajouter des conditions, “ILIKE” ou “LIKE” pour des comparaison de chaînes de caractères basés sur des patterns qui utilisent des caractères spéciaux comme “%”, ou encore les opérateur < ou > ou = pour comparer des valeurs dans une conditions. b. Pour effectuer les tris, ajouter tout juste la syntaxe ORDER BY <colonne à trier> <valeur ASC ou DESC> à la colonne, que vous devez trier. Notez que vous pouvez trier votre résultat à travers plusieurs colonnes à la fois et selon l’ordre des colonnes à trier que vous allez établir, les résultats peuvent changer. Par exemple, ORDER BY name ASC, unit_price DESC ne retourne pas forcément le même résultat que ORDER BY unit_price DESC, name ASC. c. Pour effectuer la pagination, modifier le script SQL précédent en gardant le tri ORDER BY name ASC, unit_price DESC, et essayez d’obtenir uniquement un élément de la deuxième page, autrement dit, chaque page pour nous correspond à un élément. Les mots clés à retenir sont “LIMIT” qui va limiter le nombre de résultats retournés, et “OFFSET” qui va permettre de “pointer le curseur” directement aux résultats attendus. Pour rappel, la première valeur de OFFSET commence à 0. Si tout fonctionne, normalement vous devrez avoir comme résultat l’ingrédient Saucisse. Pour la partie JAVA : 1. Créer des classes correspondantes aux énoncés ci-dessus. 2. Avant d’effectuer la configuration de la connexion avec la base de données, essayez de créer des données statiques issues d’un ArrayList directement, qui correspondent aux données de tests (Plat “Hot Dog” et ses ingrédients). Plutôt que de prendre les données à manipuler dans la base de données dans le calcul des coûts des ingrédients du plat “Hot Dog”, vous allez récupérer les données directement depuis l’ArrayList qui contiennent les données de tests statiques. Vous pouvez utiliser le nom “StaticDataSource” par exemple pour cela. 3. Créer une méthode getIngredientCost() qui retourne un Integer, dans la classe Dish. Dans l’implémentation de cette méthode, vous aurez à itérer tous les éléments de la liste Ingredients à travers une boucle et un accumulateur par exemple pour calculer les coûts de chaque ingrédient d’un plat en fonction de la quantité qui est requise. PS : La bonne pratique reste l’utilisation des Stream à la place des boucles classiques (for, while, etc). 4. Créer une classe de test, ajouter la méthode qui va vérifier que le résultat attendu est bien 5500. Respecter la forme du standard de nos tests divisés en 3 parties : les données de test et les résultats attendus en première partie, le sujet de test (la méthode à tester) en deuxième partie, et les vérifications en troisième partie. 5. Une fois que les tests passent, configurer proprement les DAO qui permettent d’obtenir les données de test depuis la base de données et non depuis le StaticDataSource. Notamment, l’objectif est d’avoir une classe DishDAO, qui a une méthode qui retourne un Dish par ID par exemple, implémenter là de sorte à obtenir une liste de Ingredients correspondants et les quantités requises lorsqu’on instancie un nouveau Dish, c’est à dire, lorsqu’il y a new Dish(...). Si vous avez correctement implémenté l’accès aux données, le test qui a marché lorsque les données étaient statiques va toujours continuer de passer.
TD centrés sur Spring-Boot Objectifs académiques : - Prise en main du framework Spring-Boot - Mise en place d’un projet sous Spring-Boot - Ajout de dépendances/modules sur Spring : DevTools, Postgres JDBC Driver - Compréhension des avantages et limites de Spring-Boot à travers des cas d’expérience - Manipulation des objets gérés par le conteneur Spring - Configuration des objets gérés par le conteneur Spring - Passage de la spécification OAS à l’implémentation Pré-requis : - Avoir une version à jour de Postman pour tester les requêtes - Avoir une connexion internet ou un projet spring-boot valide TD1 : Ping - pong ! En se référant au tutoriel fourni par le site de documentation officielle de Spring suivant https://spring.io/guides/gs/spring-boot : 1. Implémentez le point d’entrée GET /ping qui va retourner le texte “pong”. 2. Mettez ce point d’entrée dans un RestController qui s’intitule HealthRestController TD2 : Manipulez les paramètres d’entrées et les réponses en sortie Sur Spring, il est possible de spécifier le verbe HTTP pour chaque chemin (path) en utilisant une annotation spécifique à chaque verbe qui prend en paramètre le chemin correspondant : ● @GetMapping(“/chemin”) permet de spécifier que le verbe destiné à être utilisé pour chemin /chemin est GET. ● @PostMapping(“/chemin”) permet de spécifier que le verbe destiné à être utilisé pour chemin /chemin est POST. ● Etc pour les autres verbes. NB : Notez bien qu’un chemin peut être utilisé sur plusieurs verbes HTTP différents. Par exemple : GET /users ; POST /users ; PUT /users sont tous valables Autrement dit, si on veut implémenter le point d’entrée GET /ping, il faut utiliser @GetMapping(“/ping”) 1. Implémenter le nouveau point d’entrée GET /ingredients qui retourne la liste d’objets JSON Ingredient qui possède les propriétés et valeurs suivantes : Haute École d’Informatique [https://hei.school] © Copyright 2025 [{"id": 1,"name": "Oeuf","unitPrice": 1000.0,"updatedAt": "2025-03-01T00:00:00Z"},{"id": 2,"name": "Huile","unitPrice": 10000.0,"updatedAt": "2025-03-20T00:00:00Z"}]Il est important de souligner que ces données doivent être des objets statiques retournées directement depuis le RestController. En particulier, la classe ResponseEntity fournie par le framework, permet de personnaliser la réponse HTTP retournée, notamment la ligne de statut, les en têtes et le corps de la réponse. Utilisez le pour retourner une réponse ayant un code de statut 200 avec le corps de la réponse contenant la liste en JSON mentionnées plus tôt. 2. On veut pouvoir paramétrer un filtre pour filtrer les données obtenues de la requête effectuée sur le point d’entrée GET /ingredients. Pour procéder, nous allons ajouter deux paramètres de requête, pour effectuer un filtre sur le prix des ingrédients qu’on veut obtenir. Voici les dits paramètres : - priceMinFilter, de type nombre, qui va permettre de filtrer les ingrédients ayant un prix supérieur ou égale à la valeur fournie - priceMaxFilter, de type nombre qui va permettre de filtrer les ingrédients ayant un prix inférieure ou égale à la valeur fournie Haute École d’Informatique [https://hei.school] © Copyright 2025 Ces deux paramètres doivent être optionnels ce qui veut dire aucun d’eux peut être fourni, un seul ou les deux. Dans le cas où les deux sont fournis, il faut que les ingrédients obtenus se situent entre les deux intervalles (fermées). Sur Spring-boot, il suffit d’utiliser @RequestParam et spécifier en paramètre si c’est optionnel ou pas, pour spécifier un paramètre de requête. Pour rappel voici un exemple d’URL à tester sur Postman, contenant un paramètre de requête : GET base_url/ingredients?priceMinFilter=0&priceMaxFilter=1000 3. Dans le cas où les valeurs passées au filtre précédent est négatif ou bien si le priceMaxFilter est inférieur au priceMinFilter, retourner une erreur 400 indiquant un message que le priceMinFilter (<sa valeur>) ne peut pas être supérieur à priceMaxFilter (<sa valeur>). Vous pouvez configurer ça encore avec la classe ResponseEntity.4. Il est également possible de transmettre des données dans une requête HTTP en utilisant le corps de la requête. Utilisez l’annotation @RequestBody pour permettre de spécifier le corps à fournir.a. Implémenter le point d’entrée POST /ingredients qui prend en paramètre une liste d’objet JSON Ingrédient suivant les spécifications antérieures, et retourne la liste fournie en sortie.b. Créer un autre point d’entrée PUT /ingredients qui permet de faire la même chose.5. Enfin, créer un point d’entrée qui permet de prendre un ingrédient par ID, en utilisant un paramètre de chemin et non de requête, notamment en implémentant le point d’entrée GET /ingredients/<id à fournir>. Pour cela, vous devez utiliser l’annotation @PathVariable, qui permet de spécifier qu’un paramètre est considéré comme paramètre dans le chemin de l’URL spécifié. En particulier, effectuez le filtre dans le RestController qui permet de réellement chercher l'ingrédient possédant l’ID fourni. Si l’ingrédient est retrouvé, alors il faut retourner l'élément, sinon retourner une réponse 404 avec dans le corps, le message “Ingredient=<id fourni> is not found”. Par exemple, on doit effectuer GET /ingredients/1 où 1 est l’ID qu’on veut chercher, dans le cadre des paramètres de chemin. Haute École d’Informatique [https://hei.school] © Copyright 2025 TD3 : Séparez la résponsabilité et les rôles de chaque composant Il y a quatres principaux composant qu’il faut distinguer dans le cadre de l’implémentation de webservice sur Spring-Boot : - RestController, permettant de paramétrer les entrées (point d’entrée, paramètre) et les sorties (Réponse HTTP) correspondant aux services (traitements) demandés par le consommateur externe (Postman par exemple). Au sein du Controller, il ne doit qu’invoquer les services permettant d’effectuer les calculs et effectuer des conversions (mapping) entre les types de données internes et externes si nécessaires. - Service, contenant les traitements complexes à effectuer sur les données fournies par le Controller, et ceux qui accèdent potentiellement aux données persistées sur les bases de données en invoquant le Repository. - Repository, indiquant les classes permettant d’accéder aux données telles que les bases de données, les fichiers ou encore d’autres sources de données externes (cloud par exemple ou un API tiers plus génériquement). - Les autres : ce qui n’est pas défini principalement par les trois couches présentées plus tôt, font également partie des bonnes pratiques de séparation de responsabilités, notamment : - Les Configurations, comme son nom l'indique, permet de sauvegarder des données utiles à d’autres objets dans le cadre de la configuration d’un service. Par exemple, dans le cadre de la configuration de la base de données, il faut configurer les variables permettant d’accéder à la base de données, donc cette configuration se fait dans une classe annotée par @Configuration pour permettre à Spring d’identifier qu’elle est destinée à configurer quelque chose plus tard. Un autre exemple, c’est lorsque vous devez connecter votre application à un autre API, où il faut avoir des API keys pour permettre à l’API auquel vous voulez vous connecter de vous identifier. Les API keys sont des chaînes de caractères, similaires aux mots de passe pour les utilisateurs, qui permettent d’authentifier des API auprès d’autres API. - Les Mapper, qui servent à convertir des données en des types spécifiques. Un mapper doit ainsi obligatoirement avoir un type de données en entrée et un type de donnée de retour. Ce composant est particulièrement utile, lorsqu’on veut transformer des données entre la base de données et les classes dites “model”, si les attributs présentent des différences énormes. De même, entre les classes “model” utilisées dans les calculs (les Services en particulier) vers les données de sortie dans la réponse HTTP. Nous allons travailler plus sur cette partie ultérieurement. 1. Reprenez le mini-projet sur la gestion de restaurant, structurez les classes en fonction de cette séparation de responsabilité attendue (RestController, Service, Repository, Configuration, Mapper si nécessaire). Commencez par la configuration de la base de Haute École d’Informatique [https://hei.school] © Copyright 2025 données et les services liés à l'Ingrédient uniquement pour commencer NB : Stock et Price y sont également inclus car ils permettent par la suite d’obtenir la quantité de stock disponible et le prix actuel pour un Ingredient 2. Corriger l’implémentation des points d’entrées concernant l’Ingredient, notamment : GET /ingredients avec le filtre de prix, GET /ingredients/<id de l’ingredient>, POST /ingredients et PUT /ingredients qui permettent de créer ou de modifier une liste d’ingrédients et qui retourne cette même liste. Par correction, les données ne doivent plus être statiques, mais réellement enregistrées dans la base de données et récupérées depuis la base de données. Pour le cas du filtre, étant donné que le prix est calculé selon un historique de prix, calculez-le au niveau du service. 3. Veillez à bien respecter les codes de statuts correspondant aux exceptions qui doivent être levées, notamment lorsqu’une erreur client survient, alors retourner une réponse 400, si une erreur liée au fonctionnement du serveur survient, alors retourner une réponse 500. 4. Essayez de tester l’API en utilisant la collection Postman suivante : https://drive.google.com/file/d/10giVsySJ7l_aZ-5iunPx9z20AgH3IzX-/view?usp=sharing En particulier, utiliser les données par défaut fournies durant la correction sur la version console de notre application de gestion de restaurant, notamment contenu dans db.migration.testdata et supprimer les autres données pouvant modifier les résultats. Quelles sont les remarques que vous constatez par rapport aux réponses obtenues ? Haute École d’Informatique [https://hei.school] © Copyright 2025 TD4 : Facilitation de l’exploitation de l’API Dans notre implémentation actuelle, pour définir un nouveau prix ou un mouvement de stock à un ingrédient, on utilise essentiellement PUT /ingredients avec une List<Ingredient> comme RequestBody, où chaque objet Ingredient possède une liste de Price et une liste de StockMovement. (qui par la suite peut constituer une dépendance circulaire) De ce fait, l’usage de ce point d’entrée est très abstrait, car quand bien même, l’objectif est de juste modifier le nom OU le prix OU le stock OU les trois actions en même temps, c’est le même point d’entrée. Cela constitue à la fois une complexité au niveau de l’implémentation, mais également au niveau de la consommation, pour les clients qui veulent consommer nos services API. L’idéal est donc de représenter les sous ressources dans de nouveaux points d’entrées plus spécifiques, notamment : ● Lorsqu’on veut prendre ajouter ou modifier un Price pour un ingrédient, au lieu d’utiliser /PUT ingredients et fournir une liste d’Ingredient contenant la liste de Price, on va utiliser le point d’entrée PUT /ingredients/{ingredientId}/prices qui attend comme RequestBody une liste de Price (n’étant pas associé à un Ingredient) qui va être directement sauvegardée. ● Lorsqu’on veut prendre ajouter ou modifier un StockMovement pour un ingrédient, au lieu d’utiliser /PUT ingredients et fournir une liste d’Ingredient contenant la liste de StockMovement, on va utiliser le point d’entrée PUT /ingredients/{ingredientId}/stockMovements qui attend comme RequestBody une liste de StockMovement (n’étant pas associé à un Ingredient) qui va être directement sauvegardée. Cette nouvelle approche nous oblige donc à séparer la description des objets générés par le “model” de ceux manipulés pour les ressources “rest”. Il faut donc créer un composant Mapper intermédiaire entre les ressources (objets) REST, et ceux du model. 1. Effectuez les modifications nécessaires sans toucher à la description actuelle des classes “model” et implémenter les deux nouveaux points d’entrées. 2. Notre API s’enrichit, pour faciliter la lecture, écrire la spécification OAS correspondant pour les points d’entrées actuels, en utilisant correctement les composants. Haute École d’Informatique [https://hei.school] © Copyright 2025 TD5: Facilitation de l’exploitation de l’API (Suite) Reprenons intégralement les fonctionnalités de la gestion de restauration, qui permet actuellement de gérer : - Les ingrédients (Ingredient) à prix variables ; stocks calculés ; etc. - Les plats (Dishes) : comprenant une liste d’ingrédients et une quantité respective à chaque ingrédient; prix des total des ingrédients,nombre des plats restants disponibles, etc. - Les commandes (Order) : comprenant une liste de plats avec une quantité respective et un historique de statut respectif (DishOrder) ; gestion des transitions des statuts (CREATED à DELIVERED) ; avec le prix de la commande, et le montant total. Pour faciliter la reprise de ces fonctionnalités, voilà comment nous allons procéder : ● Écrire la spécification OAS3 correspondant à la gestion de chaque ressource. En particulier, pour faciliter la lecture, vous ne devez utiliser que le verbe HTTP GET et le verbe PUT tout au long de la spécifications. N’hésitez pas à utiliser les sous-ressources autant que nécessaire, comme par exemple /ingredients/id)/prices qu’on a vu. Pour faciliter votre travail encore plus, voici les points d’entrée à considérer et à enrichir en spécifiant les paramètres d’entrée et de sortie nécessaire : a. GET /ingredients : liste des ingrédients, comprenant le prix actuel, l’historique des prix, l’historique des mouvements de stock et la quantité disponible actuelle b. PUT /ingredients/{id}/prices : ajout de liste de nouveaux prix dans l’historique à un ingrédient c. PUT /ingredients/{id}/stockMovements : ajout liste de nouveaux mouvements de stock dans l’historique à un ingrédient d. GET /dishes : liste de plats comprenant les ingrédients qui le compose ainsi que les quantités disponibles pour le plat, la liste des ingrédients sans les historiques de prix ou mouvement de stock, uniquement le prix actuel et le stock actuel de chaque ingrédient, ainsi que le nombre requis pour chaque ingrédient e. PUT /dishes/{id}/ingredients, ajout liste d’ingrédients avec leurs quantités respectives f. GET /orders/{reference} : commande portant la référence fournie sinon réponse 404, comprenant les plats qui le composent avec le prix actuel du plat et son nom uniquement, la quantité à commander pour le plat, et le statut de la commande ainsi que le statut actuel de chaque plat dans la commande. g. PUT /orders/{reference}/dishes : modifie (ET NON ajoute) la liste des plats ainsi que leur quantité à commander. La modification ici ne modifie pas les propriétés du plat en question, juste il permet de choisir quel plat ajouter dans Haute École d’Informatique [https://hei.school] © Copyright 2025 la commande et le nombre à commander. Cette requête prend également en entrée le statut de la commande, qui peut être soit CREATED, soit CONFIRMED. Pour rappel, tous les plats composés doivent également passer à CONFIRMED une fois que la commande passe à CONFIRMED. h. PUT /orders/{reference}/dishes/{dishId} : passage de statut (IN_PROGRESS, FINISHED, DELIVERED) d’un plat appartenant à une commande. Voyez bien que c’est le dishId, et non dishOrderId qui est fourni ici. ● Une fois que la spécification est écrite, créer les points d’entrées nécessaires correspondant à la spécification ainsi que les types d’entrées et de retours attendues, avant d’entrer dans le détail de chaque service qui va effectuer les traitements qui y sont associés. ● Une fois que les points d’entrées dans les RestController sont configurées correctement selon ce qui a été défini la spécification OAS3, implémentez les services et repository correspondant, en copiant directement les implémentations que vous avez effectué sur le projet console, en veillant à bien annoter les objets à être gérés par le conteneur Spring (@Component/@Repository/@Service) et leurs injections à travers l'injection par attribut (@Autowired) ou par constructeur. TD6 : Fonctionnalités du tableau de bord Un tableau de bord est un outil essentiel pour les dirigeants car il synthétise les données de leurs entreprises pour faciliter la lecture, l’interprétation et ainsi les décisions à prendre. Dans le cadre de notre contexte, l’objectif est d’abord de fournir les données liées aux ventes effectuées par mois et la durée de traitement des commandes. 1. La première fonctionnalité attendue est d’avoir un point d’entrée qui permet de lister les X plats les plus vendus dans une plage de date donnée, où X est un nombre entier naturel à fournir. (si X = 3, alors on veut obtenir les 3 plats les plus vendus). La liste doit comporter le nom du plat, le nombre de quantité vendue et le montant total obtenu durant la plage donnée pour chaque plat. Notez bien : a. Une vente est actuellement considérée comme un Order avec un statut FINISHED. Vous pouvez améliorer cela en modifiant l’implémentation mais il faut qu’une vente soit rattachée à un Order avec un statut FINISHED. b. Le prix peut être variable par jour, donc il faut calculer le montant total en fonction du prix variable. c. La liste doit être triée des plats les plus vendus aux plats les moins vendus. On peut spécifier le point d’entrée comme GET /bestSales par exemple. N’oubliez pas d’enrichir vos données de tests pour vous assurer que ça marche. 2. La deuxième fonctionnalité est d’avoir un point d’entrée qui permet d’avoir la durée de traitement d’un plat spécifique dans une plage de date donnée. On considère que Haute École d’Informatique [https://hei.school] © Copyright 2025 la durée de traitement est calculée à partir du moment où son statut passe de IN_PROGRESS jusqu’à ce que ça arrive en FINISHED. Notez bien qu’: a. Un paramètre d’entrée permet de spécifier si nous voulons prendre la durée en secondes, en minutes ou en heure. Ce paramètre est optionnel, par défaut la valeur est en seconde lorsqu’elle n’est pas fournie. b. Un second paramètre permet de spécifier si nous voulons obtenir le délai de traitement MOYEN ou MINIMUM ou bien MAXIMUM. Ce paramètre est optionnel, par défaut sa valeur est la moyenne lorsqu’elle n’est pas fournie. On peut spécifier le point d’entrée comme GET /dishes/{id}/processingTime BONUS 1 : Calcul sur Java Actuellement, les calculs sont effectués à la volée, notamment c’est à chaque fois que le consommateur envoie sa requête que les données du dashboard sont calculées en parcourant les données sauvegardées dans la base de données. Les calculs peuvent prendre plus de temps et consommer des ressources au fil du temps que les données augmentent. Aussi, si il y a plusieurs appels effectués, soit le serveur risque de crasher car il doit effectuer beaucoup de calculs plusieurs fois pour sortir un même résultat, soit il devient très coûteux car à chaque requête, beaucoup de mémoires RAM et de nombre de connexions sont consommées. Pour éviter ce gaspillage, nous allons créer un point d’entrée spécifique qui va juste effectuer le calcul et persister les données nécessaires aux dashboard à une date donnée. Ensuite, nous allons ajuster notre point d’entrée actuel, qui va juste prendre les données stockées dans la base de données calculées par le premier point d’entrée, mais il n’effectue plus des calculs à la volée. L’inconvénient de cette approche est que les données ne sont pas toujours à jour, car il faut d’abord manuellement envoyer une première requête qui permet de faire la mise à jour des données. Et une deuxième requête pour récupérer les données mises à jour à la date où la première requête a été exécutée. Voilà pourquoi il est OBLIGATOIRE, de toujours indiquer la date de dernière mise à jour des données dans avec ce genre d’approche. Concrètement, pour chaque point d’entrée précédent, nous devons ajouter les deux points d’entrées suivants : POST /bestSales avec les paramètres de plage de date qui permet d’effectuer le calcul des données et GET /bestSales avec la paramètres X en entrée et une plage de date donnée, permet toujours de récupérer les X plats les plus vendus en plus de la date de dernière mise à jour mais cette fois-ci sans avoir à calculer au moment de la requête GET. POST /dishes/{id}/processingTime, de la même manière que l’autre point d’entrée, en spécifiant la plage de date. Haute École d’Informatique [https://hei.school] © Copyright 2025 Notez bien que si les plages de dates ne sont pas identiques, alors il faut que l’API ne retourne RIEN. En effet, étant donné que les prix et les quantités sont variables selon les plages de dates, alors, il faut obligatoirement que les plages de dates soient identiques. Généralement, une plage de date doit couvrir un mois, par exemple 01/01/2025 à 31/01/2025. BONUS 2 : Calcul sur Postgres Bien que le point d’entrée doive se faire toujours sur Java, les calculs liés aux deux fonctionnalités peuvent être effectués sur Postgres et obtenus depuis un Repository puis invoqué juste dans un Service pour être utilisé dans le RestController correspondant. Cette deuxième approche permet ainsi d’obtenir le même résultat que le premier, mais en effectuant directement les calculs depuis Postgres. Il est peut être recommandé de créer des fonctions sur Postgres, afin d’éviter des redondances inutiles notamment le calcul des délais de traitements, qui prend en paramètre soit la moyenne, le minimum ou le maximum. Afin d’assurer que les résultats convergent, créer un test d’intégration qui permet de vérifier que le résultat obtenu par la première approche et la deuxième approche sont bien identiques.
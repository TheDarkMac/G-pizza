-- \c postgres

-- CREATE ROLE gpizza WITH ENCRYPTED PASSWORD 'gpizza' LOGIN CREATEDB;

-- ceci n'est qu un racourci mais pour plus de verbalite, on cree et on reattribut le proprietaire
-- CREATE -h localhost -U gpizza gpizza

-- CREATE DATABASE gpizza;
-- ALTER DATABASE gpizza OWNER TO gpizza;

DROP TABLE IF EXISTS dish_ingredient CASCADE;
DROP TABLE IF EXISTS dish CASCADE;
DROP TABLE IF EXISTS ingredient_price_history CASCADE;
DROP TABLE IF EXISTS stock CASCADE;
DROP TABLE IF EXISTS ingredient CASCADE;
DROP TYPE IF EXISTS movement_type CASCADE;
DROP TYPE IF EXISTS unit CASCADE;
DROP TABLE IF EXISTS available_quantity CASCADE;
DROP FUNCTION IF EXISTS update_available_quantity CASCADE;
DROP TABLE IF EXISTS "order" CASCADE;
DROP TABLE IF EXISTS dish_order CASCADE;
DROP TABLE IF EXISTS order_status CASCADE;
DROP TABLE IF EXISTS order_dish_status CASCADE;
DROP TYPE IF EXISTS order_status_type CASCADE;
DROP TABLE IF EXISTS market_place CASCADE;

CREATE TYPE unit AS ENUM('G','L','U');

CREATE TABLE ingredient(
    id_ingredient BIGSERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE
);

CREATE TABLE ingredient_price_history(
    id_price BIGSERIAL PRIMARY KEY,
    id_ingredient BIGINT NOT NULL,
    date_price DATE NOT NULL DEFAULT CURRENT_DATE,
    unit_price DECIMAL(10,2) NOT NULL,
    CONSTRAINT fk_ingredient FOREIGN KEY (id_ingredient) REFERENCES ingredient(id_ingredient) ON DELETE CASCADE,
    CONSTRAINT unique_price_date UNIQUE (id_ingredient, date_price)
);

CREATE TABLE dish(
    id_dish BIGSERIAL PRIMARY KEY,
    reference_dish varchar(150) UNIQUE,
    name VARCHAR(50) NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL
);

CREATE TABLE dish_ingredient(
    id_dish BIGINT,
    id_ingredient BIGINT,
    quantity DECIMAL(10,2) NOT NULL,
    unit unit NOT NULL,
    PRIMARY KEY (id_dish, id_ingredient),
    CONSTRAINT fk_ingredient_id FOREIGN KEY (id_ingredient) REFERENCES ingredient(id_ingredient) ON DELETE CASCADE,
    CONSTRAINT fk_dish_id FOREIGN KEY (id_dish) REFERENCES dish(id_dish) ON DELETE CASCADE
);

CREATE TYPE movement_type AS ENUM('IN','OUT');

CREATE TABLE stock(
    id_stock BIGSERIAL PRIMARY KEY,
    id_ingredient BIGINT,
    quantity DECIMAL(10,2),
    date_of_movement TIMESTAMP DEFAULT NOW(),
    movement_type movement_type,
    CONSTRAINT pk_stock_id_ingredient FOREIGN KEY (id_ingredient) REFERENCES ingredient(id_ingredient) ON DELETE CASCADE
);

CREATE TABLE available_quantity(
    id_ingredient BIGSERIAL PRIMARY KEY,
    available_quantity DECIMAL(10,2),
    date_of_last_movement TIMESTAMP,
    CONSTRAINT pk_available_quantity FOREIGN KEY (id_ingredient) REFERENCES ingredient(id_ingredient) ON DELETE CASCADE
);

CREATE OR REPLACE FUNCTION update_available_quantity()
RETURNS TRIGGER AS $$
DECLARE
    current_quantity DECIMAL(10,2);
BEGIN
    -- Récupérer la quantité disponible actuelle
    SELECT available_quantity INTO current_quantity
    FROM "available_quantity" as aq
    WHERE id_ingredient = NEW.id_ingredient
    FOR UPDATE;

    -- Si c'est un "OUT" et qu'il n'y a pas assez de stock
    IF NEW.movement_type = 'OUT' AND (current_quantity IS NULL OR current_quantity < NEW.quantity) THEN
        RAISE EXCEPTION 'Stock insuffisant pour l''ingrédient %', NEW.id_ingredient;
    END IF;

    -- Mise a jour de la quantite disponible
    INSERT INTO "available_quantity" (id_ingredient, available_quantity, date_of_last_movement)
    VALUES (NEW.id_ingredient,
            COALESCE(current_quantity, 0) + CASE WHEN NEW.movement_type = 'IN' THEN NEW.quantity ELSE -NEW.quantity END,
            NEW.date_of_movement)
    ON CONFLICT (id_ingredient)
    DO UPDATE SET
        available_quantity = "available_quantity".available_quantity + CASE WHEN NEW.movement_type = 'IN' THEN NEW.quantity ELSE -NEW.quantity END,
        date_of_last_movement = NEW.date_of_movement;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Création du trigger sur la table stock
CREATE TRIGGER trg_update_available_quantity
AFTER INSERT ON stock
FOR EACH ROW EXECUTE FUNCTION update_available_quantity();


-----createion de la table commande-----

CREATE TYPE order_status_type AS ENUM(
    'CREATED',
    'CONFIRMED',
    'IN_PREPARATION',
    'DONE',
    'SERVED'
);

CREATE TABLE "order"(
    id_order BIGSERIAL PRIMARY KEY,
    reference_order varchar(150) UNIQUE,
    datetime_of_order TIMESTAMP
);

CREATE TABLE dish_order(
    reference_order varchar(150),
    id_dish BIGSERIAL,
    PRIMARY KEY (id_dish, reference_order),
    quantity Integer NOT NULL,
    CONSTRAINT pk_dish_order_id_dish FOREIGN KEY (id_dish) REFERENCES dish(id_dish) ON DELETE CASCADE,
    CONSTRAINT pk_dish_order_reference_order FOREIGN KEY (reference_order) REFERENCES "order"(reference_order) ON DELETE CASCADE
);

CREATE TABLE order_status(
    reference_order varchar(150),
    order_status "order_status_type",
    datetime TIMESTAMP DEFAULT now(),
    PRIMARY KEY (reference_order,order_status),
    CONSTRAINT pk_order_status_reference_order FOREIGN KEY (reference_order) REFERENCES "order"(reference_order) ON DELETE CASCADE
);

CREATE TABLE order_dish_status(
    id_dish BIGSERIAL,
    reference_order varchar(150),
    order_status "order_status_type",
    updated_at TIMESTAMP,
    PRIMARY KEY (id_dish,reference_order,order_status),
    CONSTRAINT pk_order_dish_status_reference_order FOREIGN KEY (reference_order) REFERENCES "order"(reference_order) ON DELETE CASCADE,
    CONSTRAINT pk_order_dish_status_id_dish FOREIGN KEY (id_dish) REFERENCES "dish"(id_dish) ON DELETE CASCADE
);

CREATE TABLE sales_point (
    id integer,
    reference varchar(150) UNIQUE,
    place varchar(150)
);

CREATE TABLE best_sales(
    reference varchar(150),
    id_dish BIGINT,
    "from" DATE,
    "to" DATE,
    benefice DECIMAL(10,2),
    quantity DECIMAL(10,2),
    PRIMARY KEY (reference,id_dish,"from","to"),
    CONSTRAINT pk_best_sakes_reference FOREIGN KEY (reference) REFERENCES "sales_point"(reference) ON DELETE CASCADE
);









-- -- 1) Supprimer tous les triggers et fonctions obsolètes
-- DROP TRIGGER IF EXISTS trg_after_insert_dish_order    ON dish_order;
-- DROP TRIGGER IF EXISTS trg_after_insert_order_dish_status ON order_dish_status;

-- DROP FUNCTION IF EXISTS insert_into_dish_order_status() CASCADE;
-- DROP FUNCTION IF EXISTS trg_init_dish_order_status()       CASCADE;
-- DROP FUNCTION IF EXISTS trg_update_dish_order_status()     CASCADE;

-- -- 2) Vider la table de suivi pour ne pas avoir de doublons
-- TRUNCATE dish_order_status RESTART IDENTITY;

-- -- 3) Re-créer la table (clé primaire sur référence+plat)
-- DROP TABLE IF EXISTS dish_order_status;
-- CREATE TABLE dish_order_status (
--   reference_order      VARCHAR(150)       NOT NULL,
--   dish_id              BIGINT             NOT NULL,
--   dish_status          order_status_type  NOT NULL,
--   datetime             TIMESTAMPTZ        NOT NULL DEFAULT now(),
--   beginning_time       TIMESTAMPTZ,
--   end_time             TIMESTAMPTZ,
--   preparation_duration INTERVAL,
--   PRIMARY KEY (reference_order, dish_id),
--   FOREIGN KEY (reference_order)
--     REFERENCES "order"(reference_order) ON DELETE CASCADE,
--   FOREIGN KEY (dish_id)
--     REFERENCES dish(id_dish)        ON DELETE CASCADE
-- );

-- -- 4a) Trigger “INSERT dans dish_order → CREATED”
-- CREATE OR REPLACE FUNCTION trg_init_dish_order_status()
-- RETURNS TRIGGER AS $$
-- BEGIN
--   INSERT INTO dish_order_status(reference_order, dish_id, dish_status, datetime)
--     VALUES (NEW.reference_order, NEW.id_dish, 'CREATED', now());
--   RETURN NEW;
-- END;
-- $$ LANGUAGE plpgsql;

-- CREATE TRIGGER trg_after_insert_dish_order
--   AFTER INSERT ON dish_order
--   FOR EACH ROW
--   EXECUTE FUNCTION trg_init_dish_order_status();

-- -- 4b) Trigger “INSERT dans order_dish_status → UPDATE unique”
-- CREATE OR REPLACE FUNCTION trg_update_dish_order_status()
-- RETURNS TRIGGER AS $$
-- BEGIN
--   UPDATE dish_order_status
--      SET dish_status         = NEW.order_status,
--          datetime            = NEW.updated_at,
--          beginning_time      = CASE WHEN NEW.order_status = 'IN_PREPARATION'
--                                      THEN NEW.updated_at
--                                      ELSE beginning_time END,
--          end_time            = CASE WHEN NEW.order_status = 'DONE'
--                                      THEN NEW.updated_at
--                                      ELSE end_time END,
--          preparation_duration = CASE WHEN NEW.order_status = 'DONE'
--                                      THEN NEW.updated_at - beginning_time
--                                      ELSE preparation_duration END
--    WHERE reference_order = NEW.reference_order
--      AND dish_id         = NEW.id_dish;
--   RETURN NEW;
-- END;
-- $$ LANGUAGE plpgsql;

-- CREATE TRIGGER trg_after_insert_order_dish_status
--   AFTER INSERT ON order_dish_status
--   FOR EACH ROW
--   EXECUTE FUNCTION trg_update_dish_order_status();
